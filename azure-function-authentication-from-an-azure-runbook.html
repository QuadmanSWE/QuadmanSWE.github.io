<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <meta name="generator" content="Jekyll">

  <title>Calling an Azure Function from an Azure Automation Runbook</title>

  <link rel="stylesheet" href="/css/main.css">
  <link rel="alternate" type="application/atom+xml" href="/feed.xml">
</head>

<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    <h1>blog.dsoderlund.consulting</h1>
    </a>
    <div class="header-links">
      <a href="/archive"><h2 class="header-link">Archive</h2></a>
<a href="/about"><h2 class="header-link">About</h2></a>

    </div>
  </div>
</header>
    <div class="container">
      <section id="main_content">
        <article>
  <h2>Calling an Azure Function from an Azure Automation Runbook</h2>
  <time datetime="2025-05-15T00:00:00+00:00" class="by-line">15 May 2025</time>
  <p>In this post I will explain how authentication in Azure Functions compare to authentication in Azure resources in general. This allows us to invoke a function from an Azure Automation Runbook.</p>

<!--more-->

<p>Too long didn’t read: Azure functions authentication requires that the accessToken audience matches the application id of the IDP tied to the function app. So even Azure resources whose managed service identities are granted access should create access tokens issued by the tenant, and with the audience of the Azure function, not the Azure resource management (<code class="language-plaintext highlighter-rouge">aud: https://management.core.windows.net/</code>) like one might think.</p>

<h2 id="background">Background</h2>

<p>I have a customer who I helped previously build simple tools for automation of their infrastructure. Their configuration and infrastructure changes through this automation due to them onboaring their new customers to their solution in which their customers can then self service a lot of the platform. As part of the infrastructure configuration management they may need one or more of:</p>

<ul>
  <li>DNS records</li>
  <li>tenant configuration in some central database</li>
  <li>New databases</li>
  <li>keycloak organizations</li>
  <li>Azure web app custom hostname with certificate binding</li>
</ul>

<p>This has worked well and good but they recently wanted to add some functionality to the automation. For this they chose Azure functions, intending to migrate away from my old powershell scripts, thus unlocking a more powerful and flexible admin dashboard. This dashboard app will for obvious reasons have a nicer time invoking Azure functions than Azure automation runbooks.</p>

<p>Running their function with Invoke-RestMethod returned a 401 and they asked me for some help.</p>

<p>Naïvly I tought that I could just use something like <code class="language-plaintext highlighter-rouge">Connect-AzAccount</code> directly in powershell and set the tenant and subscription - or use <code class="language-plaintext highlighter-rouge">az account get-access-token</code> to get something I could use to make the request, but I was met by failure.</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$AzureFunctionUrl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"https://somefunction-somenounce.region.azurewebsites.net/api/SomeFunction"</span><span class="w">
</span><span class="nv">$accessToken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">az</span><span class="w"> </span><span class="nx">account</span><span class="w"> </span><span class="nx">get-access-token</span><span class="w"> </span><span class="nt">--query</span><span class="w"> </span><span class="nx">accessToken</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">ConvertFrom-Json</span><span class="w">
</span><span class="nv">$headers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">@{</span><span class="w">
  </span><span class="s1">'Content-Type'</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'application/json'</span><span class="w">
  </span><span class="s1">'Authorization'</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Bearer </span><span class="nv">$accessToken</span><span class="s2">"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="nv">$jsonSomeBody</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">@{</span><span class="s2">"once"</span><span class="o">=</span><span class="s2">"toldme"</span><span class="p">}</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">ConverTo-Json</span><span class="w">
</span><span class="nx">Invoke-RestMethod</span><span class="w"> </span><span class="nt">-Method</span><span class="w"> </span><span class="nx">Post</span><span class="w"> </span><span class="nt">-Uri</span><span class="w"> </span><span class="nv">$AzureFunctionUrl</span><span class="w"> </span><span class="nt">-Body</span><span class="w"> </span><span class="nv">$jsonSomeBody</span><span class="w"> </span><span class="nt">-ContentType</span><span class="w"> </span><span class="s1">'application/json'</span><span class="w"> </span><span class="nt">-Headers</span><span class="w"> </span><span class="nv">$headers</span><span class="w">
</span></code></pre></div></div>

<blockquote>
  <p>Invoke-RestMethod: You do not have permission to view this directory or page.</p>
</blockquote>

<h2 id="the-problem-that-you-might-also-have">The problem that you might also have</h2>

<p>So we are dealing with an Azure function, it is not publicly available, nor available with an apikey, so we need to authenticate to be able to have our call authorized. Yet the normal way one might think of getting such an auth token is invalid. We have to go deeper.</p>

<p>As a normal user with a frontend in a browser or mobile app, usually this isn’t that hard to wrap your head around when building an application leveraging Azure functions or any serverless platform. Your functions/applications are their own thing separate from your Azure Resource Management and you will use the <code class="language-plaintext highlighter-rouge">/.auth/aad</code> or whichever oidc federation you set up. The user will navigate the browser flow and come out the other end with an access token .</p>

<p>You could do the same via a device flow to get an intermediate identity token that you can then send to Azure to get a working access token for the application.</p>

<p>You and me though, dear reader, are not any normal user. We are a powershell runtime running in Azure automation runbooks under a managed service account whose been granted access to the function. It is not feasible to use either device flow or a browser flow to authenticate. So what can we do?</p>

<h2 id="the-insight">The insight</h2>

<p>The first thing we need to realize is that we are not authenticating with the same endpoint as for Azure Resource Management which colloquially gets refered to as “Azure” in devops circles. It is per tenant and the resource we want matches the audience that is required.</p>

<p>Putting the pieces together and looking closely at the details of the Azure function I was asked to work on I figured that the authentication for it needs to look a certain way, very different from the tokens I usually work with for Azure Resource Management.</p>

<p><img src="../assets/2025-05-15_18-44-36-idp-sometenant-someaudience.png" alt="idp-sometenant-someissuer"></p>

<p>Once we are equipped with that knowledge, we can find that Microsoft has tucked in environment variables into Azure automation runbooks that helps us resolve endpoints in the runtime that acts as proxies for authentication to the resources, using their application Id as a reference.</p>

<p><a href="https://learn.microsoft.com/en-us/Azure/app-service/overview-managed-identity?tabs=portal%2Cpowershell#connect-to-azure-services-in-app-code">This is documented here</a>, but it took me quite a lot of time and google-fu to find it because as I didn’t really understand what I was really searching for.</p>

<h2 id="the-solution">The solution</h2>

<p>Using the internally accessible REST endpoint for token retrieval, a working solution can be constructed as so.</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$AzureFunctionUrl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"https://somefunction-somenounce.region.azurewebsites.net/api/SomeFunction"</span><span class="w">
</span><span class="nv">$appid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'cc334b87-fdbe-4996-aa3f-5bad192a18a6'</span><span class="w"> </span><span class="c"># some random guid representing somefunction application id</span><span class="w">
</span><span class="nv">$accessToken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Invoke-RestMethod</span><span class="w"> </span><span class="nt">-Method</span><span class="w"> </span><span class="nx">Get</span><span class="w"> </span><span class="se">`
</span><span class="w">  </span><span class="nt">-Headers</span><span class="w"> </span><span class="p">@{</span><span class="s2">"X-IDENTITY-HEADER"</span><span class="o">=</span><span class="s2">"</span><span class="nv">$</span><span class="nn">env</span><span class="p">:</span><span class="nv">IDENTITY_HEADER</span><span class="s2">"</span><span class="p">}</span><span class="w"> </span><span class="se">`
</span><span class="w">  </span><span class="nt">-Uri</span><span class="w"> </span><span class="s2">"</span><span class="si">$(</span><span class="w"> </span><span class="nv">$</span><span class="nn">env</span><span class="p">:</span><span class="nv">IDENTITY_ENDPOINT</span><span class="w"> </span><span class="si">)</span><span class="s2">?resource=</span><span class="si">$(</span><span class="nv">$appid</span><span class="si">)</span><span class="s2">&amp;api-version=2019-08-01"</span><span class="w"> </span><span class="se">`
</span><span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">Select-Object</span><span class="w"> </span><span class="nt">-ExpandProperty</span><span class="w"> </span><span class="nx">access_token</span><span class="w">
</span><span class="nv">$headers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">@{</span><span class="w">
  </span><span class="s1">'Content-Type'</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'application/json'</span><span class="w">
  </span><span class="s1">'Authorization'</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Bearer </span><span class="nv">$accessToken</span><span class="s2">"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="nv">$jsonSomeBody</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">@{</span><span class="s2">"once"</span><span class="o">=</span><span class="s2">"toldme"</span><span class="p">}</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">ConverTo-Json</span><span class="w">
</span><span class="nx">Invoke-RestMethod</span><span class="w"> </span><span class="nt">-Method</span><span class="w"> </span><span class="nx">Post</span><span class="w"> </span><span class="nt">-Uri</span><span class="w"> </span><span class="nv">$AzureFunctionUrl</span><span class="w"> </span><span class="nt">-Body</span><span class="w"> </span><span class="nv">$jsonSomeBody</span><span class="w"> </span><span class="nt">-ContentType</span><span class="w"> </span><span class="s1">'application/json'</span><span class="w"> </span><span class="nt">-Headers</span><span class="w"> </span><span class="nv">$headers</span><span class="w">
</span></code></pre></div></div>

<h2 id="further-reading-and-acknowledgements">Further reading and acknowledgements</h2>

<p>I read <a href="https://rakhesh.com/azure/authenticating-against-azure-functions-using-azure-ad/">this fantastic article by Rakhesh Sasidharan</a> which helped explain to me what was going on. While their elegant solution for device flow wasn’t useful it was fun to play around with and helped me bridge the gap of my knowledge about oidc to how Azure does things.</p>

<p><a href="https://medium.com/@relente/how-to-use-managed-identity-to-authenticate-azure-functions-70b92cb710f2">I also came across this article by Krizzia Relente</a> which I didn’t really parse as the solution to my problem because I read it before having a solid understanding of the problem actually was (the insight was that it is not about runbooks but about managed identities).</p>


</article>
      </section>
    </div>
  </div>

   <footer>
  <a href="https://creativecommons.org/licenses/by-sa/4.0">
    <span>
        <b>David Söderlund</b>
    </span>
    
    <span>© 2025</span>
  </a>
</footer>

  
    <script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-263169605-1', 'auto');
  ga('send', 'pageview');
</script>
  
</body>

</html>
